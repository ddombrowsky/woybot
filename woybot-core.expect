#!/usr/bin/expect -df
#
# NetHack automated player
#
# Maybe someday it will do the extinctionist game I seek.
#

set timeout 5
set match_max 20000

set user woybot
set pass U5ZjIwYzc5OTMyNz

set islocal 0
if { [lindex $argv 0] == "-l" } {
    set islocal 1
}
if { $islocal == 1 } {
    spawn nethack -u woybot
} else {
    spawn telnet nethack.csh.rit.edu

    sleep 1

    expect {
        timeout {
            send_user "can't connect, must bail\n\n"
            exit
        }
        "=>"
    }

    send "l$user\r$pass\r"

    sleep 1

    expect {
        timeout exit
        "Logged in as: $user"
    }

    send "p"

    sleep 1
}

set isnew 0
expect {
    timeout exit
    "There are some stale" {
        sleep 10
        exp_continue
    }
    "Shall I pick a character's race" {
        # wizard human male neutral
        send "nwhmn"
        set isnew 1
        exp_continue
    }
    -re "--More--" {
        send " "
        exp_continue
    }
    "to NetHack"
}

if { $isnew } {
    # put on rings
    send "PdrPe"
}

# 0.05 sec delay every 1 char
set send_slow {1 0.01}

send -s ";.v"
expect {
    timeout exit
    -re "--More--" {
        send " ;.v"
        exp_continue
    }
    "Unix NetHack"
}

set opposite_dir(h) "l"
set opposite_dir(j) "k"
set opposite_dir(k) "j"
set opposite_dir(l) "h"
set opposite_dir(y) "n"
set opposite_dir(u) "b"
set opposite_dir(b) "u"
set opposite_dir(n) "y"

set doauto 1
set idle_count 0
set isdead 0
set issatiated 0
set searching 201

#
# procs
#

# When interested in objects, only detect
# on orthagonal directions.  This is because
# we can't detect if it's in a doorway and thus
# can't move diagnoally into it.
proc is_orthag {dir} {
    if { [lsearch {h j k l} $dir] >= 0 } {
        return $dir
    } else {
        send_error "XXX: ignoring, not orthagonal\n"
        return ""
    }
}

array set tolook_walls {}
set prevdir ""
set cdir_count 0

proc interested {dir} {
    set ret ""

    if { $dir != $::prevdir } {
        send_error "XXX: new direction $::prevdir -> $dir, resetting wall counts\n"
        # direction changed, reset corridor search counts
        foreach l [list y u h j k l b n] {
            set ::tolook_walls($l) 0
        }
        set ::prevdir $dir
    }

    if { $::cdir_count > 0 } {
        incr ::cdir_count -1
    }

    # For proper corridor detection, diagonals
    # must be listed first
    set tolook [list y u b n h j k l]

    foreach l $tolook {
        set iswall 0
        set retry 10

        send ";"

        set timeout 0.5
        expect {
            timeout {
                # something's up, try again
                send " ;"
                incr retry -1
                if { $retry > 0 } {
                    exp_continue
                }
            }
            -re "You fry to a crisp|You die\\." {
                set ::isdead 1
                return "";
            }
            "Do you want your possessions identified" {
                # something happened, and we're dead
                set ::isdead 1
                return "";
            }
            "(end) " {
                send " "
                exp_continue
            }
            -gl "--More--" {
                send " "
                exp_continue
            }
            "Pick an object"
        }

        send -s "${l}.v"
        set timeout 10
        expect {
            timeout {
                send_error "XXX: ERROR: didn't find version string\n"
                exit
            }
            -re "You fry to a crisp|You die\\." {
                set ::isdead 1
                return "";
            }
            -re "Call a (.*):" {
                set obj $expect_out(0,string)
                send "unknown $obj\r"
                return "";
            }
            "woybot" {
                # ignore self, retry
                return [interested $dir]
            }
            -re {\[H[a-zA-Z&@:]       } {
                # monster, we care
                set monst $expect_out(0,string)
                set tame 0
                expect -timeout 0 "tame" {
                    set tame 1
                }

                if { $tame } {
                    send_error "XXX: int: ignoring tame $monst\n"
                    exp_continue
                } else {
                    send_error "XXX: int: found monster $monst at $l\n"
                    set ret $l
                }
            }
            "(open door)" {
                # rule: only turn into doors
                if { ($::opposite_dir($dir) == $l) || ([lsearch [list l k j h ] $dir ] < 0) } {
                    send_error "XXX: int: NOT backing up into open door at $l\n"
                } elseif { $::cdir_count <= 0 } {
                    send_error "XXX: int: found open door at $l\n"
                    set ret $l
                }
             }
            "\\+       a spellbook or a closed door (closed door)" {
                # door, we care
                send_error "XXX: int: found closed door at $l\n"
                set ret $l
            }
            "(staircase down)" {
                send_error "XXX: int: found staircase down at $l\n"
                set ret $l
            }
            -re "\\|       |-       |\\(dark part of a room\\)" {
                # wall or dark part of room
                incr ::tolook_walls($l)
                send_error "XXX: int: found wall at $l, tolook_walls($l) $::tolook_walls($l)\n"
                set iswall 1
                exp_continue
            }
            "^       a trap" {
                exp_continue
            }
            -re "\\.       |\\(corridor\\)" {
                # Detect when we're searcing along a wall and
                # find an opening.
                if { $::tolook_walls($l) > 2 } {
                    if { $::opposite_dir($dir) != $l } {
                        set ret $l
                        set swhy "after $::tolook_walls($l) wall(s))"
                    }
                } elseif { $::cdir_count <= 0 } {
                    if { [lsearch [list j k] $dir] >= 0 } {
                        # If we're moving vertically past an
                        # opening east or west, then be interested.
                        switch $l {
                            "h" {
                                if { $::tolook_walls(y) > 0 &&
                                     $::tolook_walls(b) > 0 } \
                                {
                                    set ret "h"
                                    set swhy "walls on y,b"
                                }
                            }
                            "l" {
                                if { $::tolook_walls(u) > 0 &&
                                     $::tolook_walls(n) > 0 } \
                                {
                                    set ret "l"
                                    set swhy "walls on u,n"
                                }
                            }
                        }
                    } elseif { [lsearch [list h l] $dir] >= 0} {
                        # If we're moving horizontally past an
                        # opening north or south, then be interested.
                        switch $l {
                            "j" {
                                if { $::tolook_walls(b) > 0 &&
                                     $::tolook_walls(n) > 0 } \
                                {
                                    set ret "j"
                                    set swhy "walls on b,n"
                                }
                            }
                            "k" {
                                if { $::tolook_walls(y) > 0 &&
                                     $::tolook_walls(u) > 0 } \
                                {
                                    set ret "k"
                                    set swhy "walls on y,u"
                                }
                            }
                        }
                    }
                }
                set ::tolook_walls($l) 0
                if { $ret == "" } {
                    exp_continue
                } else {
                    send_error "XXX: int: found an opening at $l ($swhy)\n"
                }
            }
            -re "#       |\{       |<       " {
                exp_continue
            }
            -re "%       .*corpse" {
                # old corpse, not interested
                exp_continue
            }
            -re "%       " {
                send_error "XXX: int: found a piece of food at $l\n"
                set ret [is_orthag $l]
            }
            ")       a weapon" {
                send_error "XXX: int: found a weapon at $l\n"
                set ret [is_orthag $l]
            }
            "\\\[       a suit" {
                send_error "XXX: int: found a suit at $l\n"
                set ret [is_orthag $l]
            }
            "\\$       " {
                send_error "XXX: int: found some gold at $l\n"
                set ret [is_orthag $l]
            }
            "Unix NetHack Version 3.4.3" {
                # done!
            }
            "You hear" {
                # sounds can make the version string go
                # away (?), so accept it.
            }
            -gl "--More--" {
                send " "
                exp_continue
            }
        }

        if { !$iswall } {
            # If we found anything but a wall in this direction,
            # reset the passage search counter.
            set ::tolook_walls($l) 0
        }
        if { $ret != "" } {
            # to avoid thrashing around in corners, set a
            # timeout for switching directions.
            set ::cdir_count 4
            break
        }

        # Last-change timeout: if our wall counts are super
        # high, then we're stuck (e.g. invisible and at the
        # edge of the map).
        if { $::tolook_walls($l) > 80 } {
            send_error "XXX: STUCK, reversing direction\n"
            set ret $::opposite_dir($dir)
            break
        }

    }

    return $ret
}

proc pickup {type} {
    send -s ","
    expect {
        -timeout 5
        "(end)" {
            send -s "${type} "
            exp_continue
        }
        "There is nothing here to pick up" {
        }
        -gl "--More--" {
            send -s " ,"
            exp_continue
        }
        -re "(.) - " {
            return $expect_out(1,string)
        }
    }
}

proc move_into_door {dir} {
    # attempt to move in front of the door
    switch $dir {
        "y" { send "hkh" }
        "u" { send "lkl" }
        "b" { send "hjh" }
        "n" { send "ljl" }
    }
}

proc after_attack {dir} {
    expect {
        -timeout 1
        "You miss " {
            # nothing
        }
        "You hit " {
            # nothing
        }
        -re "You (kill|destroy) the (.*)!" {
            set monname $expect_out(2,string)
            send_error "XXX: killed $monname\n"
            send "${dir}"
            exp_continue
        }
        -re "The (\[a-zA-Z \]+) is killed!" {
            set monname $expect_out(1,string)
            send_error "XXX: something killed $monname\n"
            send "${dir}"
            exp_continue
        }
        -re "a (\[a-zA-Z \]+) corpse" {
            set monst $expect_out(1,string)

            if { [lsearch {
                "kobold"
                } $monst] < 0 } {
                # eat the corpse
                if { !$::issatiated } {
                    send_error "XXX: eating ($monst corpse)\n"
                    send " ey"
                } else {
                    send_error "XXX: not eating ($monst corpse), too full\n"
                }
            } else {
                send_error "XXX: NOT eating slain $monst corpse\n"
            }
        }
    }
}

#
# explore
#

set dirs [list h y u y h y j y k y l y b y n u y u h u j u k u l u b u n h y h u h j h k h l h b h n j y j u j h j k j l j b j n k y k u k h k j k l k b k n l y l u l h l j l k l b l n b y b u b h b j b k b l b n n y n u n h n j n k n l n b ]

while {$doauto == 1} {
    foreach dir $dirs {
        send_error "XXX DIRECTION: $dir, search count $searching\n"
        set cont 1
        set ::issatiated 0
        while {$cont == 1} {
            # if we haven't seen anything interesting in 200
            # iterations, start searching.
            if { $searching > 200 } {
                send_error "XXX: searching\n"
                send -s "s"
            }

            send ":"

            #
            # FIRST: identify the current square
            #
            expect {
                -re "You fry to a crisp|You die\\." {
                    set isdead 1
                    exp_continue
                }
                "There is an open door here" {
                    set cont 0
                    switch $dir {
                        "y" { set dir "h" }
                        "u" { set dir "k" }
                        "b" { set dir "j" }
                        "n" { set dir "l" }
                    }
                    set timeout 0 ; exp_continue
                }
                -re "You (see|feel) no objects here" {
                }
                "There is a doorway here" {
                    set timeout 0 ; exp_continue
                }
                "There is a broken door here" {
                    set timeout 0 ; exp_continue
                }
                "There is a staircase up here" {
                    set timeout 0 ; exp_continue
                }
                "There is a fountain here" {
                    set timeout 0 ; exp_continue
                }
                "You see" {
                    set timeout 0 ; exp_continue
                }
                -gl "--More--" {
                    send " "
                    set timeout 0 ; exp_continue
                }
            }

            if { $isdead } {
                break
            }

            #
            # SECOND: identify the next square, make
            # move, handle extreme hunger
            #
            send -s ";$dir."

            set timeout 2
            expect {
                timeout {
                    send_error "XXX: invalid state when identifying next square\n"
                    exit
                }
                "Pick an object"
            }
            expect {
                timeout {
                    # don't care
                    set cont 0
                    incr idle_count
                    send_error "XXX: unknown response, idle_count $idle_count\n"
                }
                # hunger emergency comes first
                -re "Weak|Fainting|Fainted|FoodPois" {
                    # place a call!
                    #send "#py"
                    send "#pray\ry"
                    sleep 0.1
                    expect {
                        -timeout 3
                        "You feel that" {
                            send_error "XXX: done with the call\n"
                        }
                        "angered" {
                            # uh oh...
                            sleep 2
                            exp_continue
                        }
                        -re "You fry to a crisp|You die\\." {
                            send_error "XXX: and the false god hath made us DEAD again\n"
                            set isdead 1
                            set cont 0
                            set doauto 0
                        }
                        -gl "--More--" {
                            send " "
                            sleep 1
                            exp_continue
                        }
                    }
                }
                -re "You fry to a crisp|You die\\." {
                    send_error "XXX: well look at that, DEAD again\n"
                    sleep 1
                    set isdead 1
                }
                "Really attack" {
                    # don't violate paranoid attack
                    send " "
                    set cont 0
                    incr idle_count
                }
                "woybot" {
                    # If we're looking at ourselves then we
                    # must be at the edge of the map.
                    set cont 0
                    incr idle_count
                }
                "(wall)" {
                    # don't care
                    set cont 0
                    incr idle_count
                }
                "(dark part of a room)" {
                    if { $searching > 200 } {
                        send_error "XXX: end of corridor? 5 turn SEARCH\n"
                        send "15s"
                        # bump up idle count to force a quick change
                        incr idle_count 25
                    } else {
                        # don't care
                        set cont 0
                    }
                    incr idle_count
                }
                "\\^       a trap" {
                    set cont 0
                    incr idle_count
                }
                "\\0       an iron ball or boulder" {
                    send -s "$dir"
                    expect {
                        -timeout 0
                        timeout {
                            set cont 1
                        }
                        "You try to move the boulder, but in vain." {
                            set cont 0
                            incr idle_count
                        }
                        "You hear a monster behind the boulder." {
                            # attempt to wait it out
                            send "s$dir"
                            incr idle_count
                            if { $idle_count > 100 } {
                                set cont 0
                            } else {
                                exp_continue
                            }
                        }
                        "you move the boulder" {
                            set cont 1
                        }
                    }
                }
                "\\+       a spellbook or a closed door (closed door)" {
                    send -s "o$dir"
                    sleep 0.25
                    expect {
                        "This door is locked." {
                            send \004
                            send "$dir"
                        }
                        -re "The door opens|The door resists!" {
                            if { $expect_out(0,string) == "The door opens" } {
                                move_into_door $dir
                            } else {
                                send "$dir"
                            }
                            set cont 1
                            set idle_count 0
                        }
                    }
                    set searching 0
                }
                ".       a doorway or the floor of a room" {
                    send "$dir"
                    set cont 1
                    set idle_count 0
                    incr searching
                }
                "(open door)" {
                    # doors can only be entered orthogonally
                    if { [lsearch [list l k j h ] $dir ] >= 0 } {
                        send "$dir"
                        set cont 1
                        set idle_count 0
                        # autosearch the next move, to prevent getting
                        # stuck trying to move diagonally out of it
                        set searching 201
                    } else {
                        # attempt move in front of the door
                        move_into_door $dir
                        set cont 0
                        set searching 201
                    }
                }
                -re "#       iron bars or a tree" {
                    expect {
                        "(corridor)" {
                            expect -timeout 0 -gl "--More--" { send " " }
                            # travel down corridors if not searching
                            if { $searching > 200 } {
                                send "g"
                            } else  {
                                send "G"
                            }
                            send "$dir"
                            set cont 1
                            set idle_count 0
                            incr searching
                        }
                        "(sink)" {
                            send "$dir"
                            set cont 1
                            set idle_count 0
                        }
                    }
                }
                -re "(tame \\w+ called Mountain Lion Cat)" {
                    send "$dir"
                    set cont 1
                    set idle_count 0
                }
                "<       a staircase up or a ladder up (staircase up)" {
                    send "$dir"
                    set cont 1
                    set idle_count 0
                }
                ">       a staircase down or a ladder down (staircase down)" {
                    send "$dir>"
                    set cont 1
                    set idle_count 0
                    set searching 0
                }
                -re "%       a piece of food \\((\[^)\]+)\\)" {
                    if { $expect_out(1,string) == "corpse" } {
                        send -s "$dir"
                        set monst "unknown"
                        expect {
                            -timeout 5
                            timeout {
                                # If the corpse is in a doorway, and we can't
                                # enter diagonally, it is detected by
                                # this timeout.
                                set cont 0
                                incr idle_count
                            }
                            -re "You see here a (\[a-zA-Z \]+) corpse" {
                                set monst $expect_out(1,string)
                            }
                        }

                        if { $monst == "lichen" } {
                            if { !$::issatiated } {
                                send_error "XXX: eating (lichen)\n"
                                send "ey"
                            } else {
                                send_error "XXX: not eating (lichen), too full\n"
                            }
                        } else {
                            send_error "XXX: not eating $monst corpse!\n"
                        }
                    } elseif { $expect_out(1,string) == "tin" } {
                        send_error "XXX: not eating tin!\n"
                        send "$dir"
                    } else {
                        if { !$::issatiated } {
                            send_error "XXX: eating (found food)\n"
                            send "${dir}ey"
                        } else {
                            send_error "XXX: not eating (found food), too full\n"
                        }
                    }

                    # rescan the output, looking for "Satiated"
                    exp_continue
                }
                "(       a useful item" {
                    send "$dir"
                    set cont 1
                }
                "*      a gem or rock" {
                    send "$dir"
                    set cont 1
                }
                "(statue of a" {
                    send "$dir"
                    set cont 1
                    set idle_count 0
                }
                "\{       a fountain" {
                    send "$dir"
                    set cont 1
                    set idle_count 0
                }
                "\$       " {
                    # pick up cash
                    send "$dir,"
                    expect {
                        "(end)" {
                            # multiple items, choose only gold
                            send "\$ "
                            exp_continue
                        }
                        "gold pieces"
                    }
                    set idle_count 0
                }
                "?       a scroll" {
                    send -s "${dir}"
                    pickup "?"
                    incr idle_count
                }
                "!       a potion" {
                    send -s "${dir}"
                    pickup "!"
                    incr idle_count
                }
                ")       a weapon" {
                    send "${dir}"
                    pickup ")"
                    incr idle_count
                }
                "\\\[       a suit" {
                    send "${dir}"
                    set c [pickup "\["]
                    if { $c != "" } {
                        send "W$c"
                    }
                    incr idle_count
                }
                "/       a wand" {
                    send "${dir}"
                    set c [pickup "/"]
                    if { $c != "" } {
                        send "z$c$dir"
                    }
                    incr idle_count
                }
                -re "e       .*\\(floating eye\\)" {
                    send -s "Za$dir"
                    sleep 0.1

                    after_attack $dir
                }
                -re ":       |d       |x       |r       |F       |o       |k       |Z       |B       |s       |h       |G       |f       |i       |@       " {
                    set monst "UNKNOWN"
                    set monname "UNKNOWN"
                    # attack!
                    send_error "XXX: attack!\n"
                    send -s "$dir"
                    sleep 0.1

                    after_attack $dir

                    set cont 1
                    set idle_count 0
                }
                -re "b       .*\\(acid blob\\)|e       .*\\(gas spore\\)" {
                    if { $idle_count > 5 } {
                        send "$dir"
                    }
                    # avoid
                    set cont 0
                    incr idle_count
                    # autosearch next turn, since finding a
                    # monster would have cleared it
                    set searching 300
                }
                "Satiated" {
                    set ::issatiated 1
                    incr idle_count
                }

                # "--More--" must come last, to avoid losing
                # anything that came before it "e.g. "You die..."
                -gl "--More--" {
                    send " "
                    set cont 1
                    exp_continue
                }
            }

            if { $isdead } {
                break
            }

            #
            # THIRD: identify the surrounding squares
            #
            set ndir [interested $dir]
            if { $ndir != "" } {
                send_error "XXX: interested in direction $ndir\n"
                set dir $ndir
                set cont 1
                incr searching -20
            } else {
                send_error "XXX: idle_count $idle_count searching $searching\n"

                # clear out the More-s
                expect {
                    -timeout 0
                    -re "You fry to a crisp|You die\\." {
                        set cont 0
                        set isdead 1
                    }
                    "Do you want your possessions" {
                        set cont 0
                        set isdead 1
                        send \020
                    }
                    -gl "--More--" {
                        send " "
                        exp_continue
                    }
                }

                if { $isdead } {
                    set cont 0
                }
            }

            if { $idle_count > 50 } {
                # might be stuck, change direction
                set cont 0
            }
        }

        if { $isdead } {
            set deathlog [open "death.log" w]
            puts $deathlog $expect_out(buffer)
            set send_slow {1 2}
            set doauto 0
            # try and get the last few messages on the screen
            expect "Do you want your possessions" {
                send \020
            }
            # cycle through the stats
            expect {
                -timeout 1
                -re "--More--|(end)" {
                    send -s " "
                    flush stdout
                    sleep 1
                    puts $deathlog $expect_out(buffer)
                    exp_continue
                }
                "yn" {
                    send -s "y"
                    flush stdout
                    sleep 1
                    puts $deathlog $expect_out(buffer)
                    exp_continue
                }
            }
            flush stdout
            close $deathlog
            break
        }
    }
    if { !$isdead } {
        send "s"
        if { $idle_count >= [llength $dirs] } {
            send "."
            if { $idle_count > 1000 } {
                # bail...
                #set doauto 0
                set searching 200
            }
        }
    }
}

if { !$isdead } {
    send_error "XXX: INTERACT\n"
    interact
}

send_error "XXX: clean exit\n"
